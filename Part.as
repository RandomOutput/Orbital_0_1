package{	import flash.display.MovieClip;	import StaticInputHandler;		import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Dynamics.Joints.*;	import Box2D.Dynamics.Contacts.*;	import Box2D.Common.Math.*;		public class Part extends MovieClip	{		public var justCreated:Boolean = true;		public var dockingPins:Vector.<DockingPin>;		public var thrustEnabled = false;				private var body_part:b2Body;		private var partVisual:MovieClip;		private var partType:String;		private var world:b2World;		public function Part(_world:b2World, _partType:String = "")		{			super();			dockingPins = new Vector.<DockingPin>();			world = _world;			partType = _partType;			init();		}		public function init():void		{			var BD_part:b2BodyDef = new b2BodyDef();			var FD_part:b2FixtureDef = new b2FixtureDef();			var boxDef:b2PolygonShape = new b2PolygonShape();			switch(partType)			{				case "playerShip":					//Physics					BD_part.type = b2Body.b2_dynamicBody;					FD_part.shape = boxDef;					FD_part.density = 1;					FD_part.friction = 0.5;					FD_part.restitution = 0.1;					boxDef.SetAsBox(41 / 2 / StaticConfigHandler.pixelsPerMeter, 100 / 2 / StaticConfigHandler.pixelsPerMeter);					BD_part.position.Set(320 / StaticConfigHandler.pixelsPerMeter, 240 / StaticConfigHandler.pixelsPerMeter);					body_part = world.CreateBody(BD_part);					body_part.CreateFixture(FD_part);					this.thrustEnabled = true;					//Docking					dockingPins.push(new DockingPin(new b2Vec2(0, -100/2/StaticConfigHandler.pixelsPerMeter), 0));					//Visuals					partVisual = new Commander();					this.addChild(partVisual);					//partVisual.alpha = 0.5;					update();					break;					break;				case "Quad Connector":					BD_part.type = 	b2Body.b2_dynamicBody;						FD_part.shape = boxDef;					FD_part.density = 1;					FD_part.friction = 0.5;					FD_part.restitution = 0.1;					boxDef.SetAsBox(80/2/StaticConfigHandler.pixelsPerMeter, 80/2/StaticConfigHandler.pixelsPerMeter);					BD_part.position.Set(100 / StaticConfigHandler.pixelsPerMeter, 50/ StaticConfigHandler.pixelsPerMeter);										body_part = world.CreateBody(BD_part);					body_part.CreateFixture(FD_part);					//Docking					dockingPins.push(new DockingPin(new b2Vec2(80/2/StaticConfigHandler.pixelsPerMeter, 0), -90));					//TODO: Visuals					partVisual = new Quad();					this.addChild(partVisual);					//partVisual.alpha = 0.5;					update();					break;				default:					//Physics					BD_part.type = b2Body.b2_dynamicBody;					FD_part.shape = boxDef;					FD_part.density = 1;					FD_part.friction = 0.5;					FD_part.restitution = 0.1;					boxDef.SetAsBox(41 / 2 / StaticConfigHandler.pixelsPerMeter, 100 / 2 / StaticConfigHandler.pixelsPerMeter);					BD_part.position.Set(320 / StaticConfigHandler.pixelsPerMeter, 240 / StaticConfigHandler.pixelsPerMeter);					body_part = world.CreateBody(BD_part);					body_part.CreateFixture(FD_part);					this.thrustEnabled = true;					//Docking					dockingPins.push(new DockingPin(new b2Vec2(0, -100/2/StaticConfigHandler.pixelsPerMeter), 0));					//Visuals					partVisual = new CSM();					this.addChild(partVisual);					//partVisual.alpha = 0.5;					update();					break;			}		}		public function checkDocking(ships:Vector.<Part>, searchIndex:int)		{			for(var i=searchIndex+1; i < ships.length; i++)			{				for each(var dPin1:DockingPin in dockingPins)				{					for each(var dPin2:DockingPin in ships[i].dockingPins)					{						//docking port b2Vec2						var pin1:b2Vec2 = this.body_part.GetWorldPoint(dPin1.localCoords);									//docking pin b2Vec2						var pin2:b2Vec2 = ships[i].getBody().GetWorldPoint(dPin2.localCoords);												//distance						var dist:Number = Math.sqrt(Math.pow(pin1.x - pin2.x, 2) + Math.pow(pin1.y - pin2.y, 2));						dist = dist * StaticConfigHandler.pixelsPerMeter;												var relAngle:Number = Math.abs((this.body_part.GetAngle() + dPin1.localAngle) - (ships[i].getBody().GetAngle() + dPin2.localAngle));						relAngle = relAngle * ( 180 / Math.PI );						relAngle = relAngle % 360;						trace("dist: " + dist);						//if distance and angle good						if(dist < 2 && relAngle < 5 && relAngle > -5)						{							doDock(ships[i], pin2);						}					}				}			}		}		public function doDock(part:Part, dPin:b2Vec2):void		{			//create joint & lock			var revoluteJointDef:b2RevoluteJointDef = new  b2RevoluteJointDef();			revoluteJointDef.Initialize(this.body_part, part.getBody(), dPin);			 			revoluteJointDef.maxMotorTorque = 1.0;			revoluteJointDef.enableMotor = true;			 			world.CreateJoint(revoluteJointDef);			part.getBody().SetType(2);			part.thrustEnabled = true;		}		public function update():void		{			if(this.thrustEnabled)			{				if(StaticInputHandler.iKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.RIGHT_VEC), body_part.GetWorldPoint(new b2Vec2(-1,-1)));				if(StaticInputHandler.oKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.LEFT_VEC), body_part.GetWorldPoint(new b2Vec2( 1,-1)));				if(StaticInputHandler.kKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.RIGHT_VEC), body_part.GetWorldPoint(new b2Vec2(-1, 1)));				if(StaticInputHandler.lKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.LEFT_VEC), body_part.GetWorldPoint(new b2Vec2( 1, 1)));				if(StaticInputHandler.uKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.DOWN_VEC), body_part.GetWorldPoint(new b2Vec2( 0, 0)));				if(StaticInputHandler.jKey) body_part.ApplyForce(body_part.GetWorldVector(StaticConfigHandler.UP_VEC), body_part.GetWorldPoint(new b2Vec2( 0, 0)));			}						this.x = body_part.GetPosition().x * StaticConfigHandler.pixelsPerMeter;			this.y = body_part.GetPosition().y * StaticConfigHandler.pixelsPerMeter;			this.rotation = body_part.GetAngle() * ( 180 / Math.PI );		}		public function getBody():b2Body		{			return body_part;		}	}}