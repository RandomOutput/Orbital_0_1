package{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Dynamics.Joints.*;	import Box2D.Dynamics.Contacts.*;	import Box2D.Common.Math.*;	import StaticConfigHandler;	import StaticInputHandler;		public class Main extends MovieClip	{		private var world:b2World;		private var timestep:Number;		private var iterations:uint;		//var shipBody:b2Body;		var dock_body:b2Body;		var ship:CSM;		var debugPort:MovieClip;		var debugPin:MovieClip;		var ships:Vector.<Ship>; 		public function Main()		{			super();						ships = new Vector.<Ship>();						makeWorld();			makeWalls();			makeDebugDraw();			if(stage) init();			else addEventListener(Event.ADDED_TO_STAGE, init);		}		private function makeWorld():void		{			//define gravity			var gravity:b2Vec2 = new b2Vec2(0.0, 0.0);			//Allow bodies to sleep			var doSleep:Boolean = true;			//Construct a world;			world = new b2World(gravity, doSleep);			world.SetWarmStarting(true);			timestep = 1.0 / 30.0;			iterations = 10;		}		private function makeWalls():void		{			var wall:b2PolygonShape = new b2PolygonShape();			var wallBd:b2BodyDef = new b2BodyDef();			var wallB:b2Body;			//Left			wallBd.position.Set( -95 / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wall.SetAsBox(100/StaticConfigHandler.pixelsPerMeter, 400/StaticConfigHandler.pixelsPerMeter/2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Right			wallBd.position.Set((640 + 95) / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Top			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, -95 / StaticConfigHandler.pixelsPerMeter);			wall.SetAsBox(680/StaticConfigHandler.pixelsPerMeter/2, 100/StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Bottom			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, (400 + 95) / StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);		}		private function makeDebugDraw():void		{			var debugDraw:b2DebugDraw = new b2DebugDraw();			var debugSprite:Sprite = new Sprite();			addChild(debugSprite);			debugDraw.SetSprite(debugSprite);			debugDraw.SetDrawScale(30.0);			debugDraw.SetFillAlpha(0.3);			debugDraw.SetLineThickness(1.0);			debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);			world.SetDebugDraw(debugDraw);		}		private function init(e:Event = null):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			stage.addEventListener(KeyboardEvent.KEY_DOWN, StaticInputHandler.onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, StaticInputHandler.onKeyUp);						StaticConfigHandler.LEFT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.RIGHT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.UP_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.DOWN_VEC.Multiply(StaticConfigHandler.FORCE_MULT);						createShip();			createDockingPort();			createDebugPoints();			addEventListener(Event.ENTER_FRAME, update);			//ship = new CSM();			//stage.addChild(ship);			//ship.alpha = 0.5;		}		private function createDebugPoints():void		{			debugPort = new DebugPoint();			debugPin = new DebugPoint();			stage.addChild(debugPort);			stage.addChild(debugPin);		}		private function createShip():void		{			var newPart = new Part(world);			var newShip = new Ship(world, newPart);			ships.push(newShip);			/*			var shipBd:b2BodyDef;			var fd:b2FixtureDef;			var boxDef:b2PolygonShape = new b2PolygonShape();			shipBd = new b2BodyDef();			shipBd.type = b2Body.b2_dynamicBody;			fd = new b2FixtureDef();			fd.shape = boxDef;			fd.density = 1;			fd.friction = 0.5;			fd.restitution = 0.1;			boxDef.SetAsBox(41 / 2 / StaticConfigHandler.pixelsPerMeter, 100 / 2 / StaticConfigHandler.pixelsPerMeter);			shipBd.position.Set(320 / StaticConfigHandler.pixelsPerMeter, 240 / StaticConfigHandler.pixelsPerMeter);			shipBody = world.CreateBody(shipBd);			shipBody.CreateFixture(fd);			*/		}		private function createDockingPort():void		{			var bd_dock:b2BodyDef = new b2BodyDef();			bd_dock.type = b2Body.b2_staticBody;			bd_dock.position.Set(100 / StaticConfigHandler.pixelsPerMeter, 50 / StaticConfigHandler.pixelsPerMeter);						var boxDef:b2PolygonShape = new b2PolygonShape();			boxDef.SetAsBox(50/2/StaticConfigHandler.pixelsPerMeter, 50/2/StaticConfigHandler.pixelsPerMeter);			var fd_dock:b2FixtureDef = new b2FixtureDef();			fd_dock.shape = boxDef;			fd_dock.density = 1;			fd_dock.friction = 0.5;			fd_dock.restitution = 0.1;						dock_body = world.CreateBody(bd_dock);			dock_body.CreateFixture(fd_dock);					}		private function makeABunchOfDynamicBodies():void		{			var i:int			var body:b2Body;			var fd:b2FixtureDef;			//Add rectangles			for (i = 0; i < 5; i++){				var bodyDef:b2BodyDef = new b2BodyDef();				bodyDef.type = b2Body.b2_dynamicBody;				var boxDef:b2PolygonShape = new b2PolygonShape();				fd = new b2FixtureDef();				fd.shape = boxDef;				fd.density = 1.0;				// Override the default friction.				fd.friction = 0.3;				fd.restitution = 0.1;				boxDef.SetAsBox((Math.random() * 5 + 10) / StaticConfigHandler.pixelsPerMeter, (Math.random() * 5 + 10) / StaticConfigHandler.pixelsPerMeter);				bodyDef.position.Set((Math.random() * 400 + 120) / StaticConfigHandler.pixelsPerMeter, (Math.random() * 150 + 50) / StaticConfigHandler.pixelsPerMeter);				bodyDef.angle = Math.random() * Math.PI;				body = world.CreateBody(bodyDef);				body.CreateFixture(fd);			}			// Add Circles			for (i = 0; i < 5; i++){				var bodyDefC:b2BodyDef = new b2BodyDef();				bodyDefC.type = b2Body.b2_dynamicBody;				var circDef:b2CircleShape= new b2CircleShape((Math.random() * 5 + 10) / StaticConfigHandler.pixelsPerMeter);				fd = new b2FixtureDef();				fd.shape = circDef;				fd.density = 1.0;				// Override the default friction.				fd.friction = 0.3;				fd.restitution = 0.1;				bodyDefC.position.Set((Math.random() * 400 + 120) / StaticConfigHandler.pixelsPerMeter, (Math.random() * 150 + 50) / StaticConfigHandler.pixelsPerMeter);				bodyDefC.angle = Math.random() * Math.PI;				body = world.CreateBody(bodyDefC);				body.CreateFixture(fd);			}			// Add irregular convex polygons			for (i = 0; i < 15; i++){				var bodyDefP:b2BodyDef = new b2BodyDef();				bodyDefP.type = b2Body.b2_dynamicBody;				var polyDef:b2PolygonShape = new b2PolygonShape();				// Draw a polygon point by point				if (Math.random() > 0.66) {					polyDef.SetAsArray([						new b2Vec2((-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter, ( 10 +Math.random()*10) / StaticConfigHandler.pixelsPerMeter),						new b2Vec2(( -5 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter, (-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter),						new b2Vec2((  5 +Math.random()*10) / StaticConfigHandler.pixelsPerMeter, (-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter),						new b2Vec2(( 10 +Math.random() * 10) / StaticConfigHandler.pixelsPerMeter, ( 10 +Math.random() * 10) / StaticConfigHandler.pixelsPerMeter)						]);				}				else if (Math.random() > 0.5)				{					var array:Array = [];					array[0] = new b2Vec2(0, (10 +Math.random()*10) / StaticConfigHandler.pixelsPerMeter);					array[2] = new b2Vec2((-5 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter, (-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter);					array[3] = new b2Vec2(( 5 +Math.random()*10) / StaticConfigHandler.pixelsPerMeter, (-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter);					array[1] = new b2Vec2((array[0].x + array[2].x), (array[0].y + array[2].y));					array[1].Multiply(Math.random()/2+0.8);					array[4] = new b2Vec2((array[3].x + array[0].x), (array[3].y + array[0].y));					array[4].Multiply(Math.random() / 2 + 0.8);					polyDef.SetAsArray(array);				}				else				{					polyDef.SetAsArray([						new b2Vec2(0, (10 +Math.random()*10) / StaticConfigHandler.pixelsPerMeter),						new b2Vec2((-5 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter, (-10 -Math.random()*10) / StaticConfigHandler.pixelsPerMeter),						new b2Vec2(( 5 +Math.random() * 10) / StaticConfigHandler.pixelsPerMeter, ( -10 -Math.random() * 10) / StaticConfigHandler.pixelsPerMeter)					]);				}				fd = new b2FixtureDef();				fd.shape = polyDef;				fd.density = 1.0;				fd.friction = 0.3;				fd.restitution = 0.1;				bodyDefP.position.Set((Math.random() * 400 + 120) / StaticConfigHandler.pixelsPerMeter, (Math.random() * 150 + 50) / StaticConfigHandler.pixelsPerMeter);				bodyDefP.angle = Math.random() * Math.PI;				body = world.CreateBody(bodyDefP);				body.CreateFixture(fd);			}		}		private function update(e:Event = null):void		{			for each(var ship:Ship in ships)			{				if(ship.justCreated) this.addChild(ship);				ship.update();			}			world.Step(timestep, iterations, iterations);			world.ClearForces();			world.DrawDebugData();		}		/*		private function checkDocking():void		{			//docking port b2Vec2			var dockingPort:b2Vec2 = dock_body.GetWorldPoint(new b2Vec2(.8,0));						//docking pin b2Vec2			var dockingPin:b2Vec2 = shipBody.GetWorldPoint(new b2Vec2(0,-1.65));			//distance			var dist:Number = Math.sqrt(Math.pow(dockingPort.x - dockingPin.x, 2) + Math.pow(dockingPort.y - dockingPin.y, 2));			dist = dist * StaticConfigHandler.pixelsPerMeter;						//relative angle			var relAngle:Number = Math.abs(dock_body.GetAngle() - shipBody.GetAngle());			relAngle = relAngle * ( 180 / Math.PI );			relAngle -= 90;						trace("dist: " + dist);			trace("relAngle: " + relAngle);			//if distance and angle good			if(dist < 3 && relAngle < 5 && relAngle > -5)			{				//create joint & lock				var revoluteJointDef:b2RevoluteJointDef = new  b2RevoluteJointDef();				revoluteJointDef.Initialize(dock_body, shipBody, dockingPin);				 				revoluteJointDef.maxMotorTorque = 1.0;				revoluteJointDef.enableMotor = true;				 				world.CreateJoint(revoluteJointDef);				dock_body.SetType(2);			}		}		*/		/*		private function updateDebugPoints():void		{			debugPort.x = dock_body.GetWorldPoint(new b2Vec2(.8,0)).x * StaticConfigHandler.pixelsPerMeter;			debugPort.y = dock_body.GetWorldPoint(new b2Vec2(.8,0)).y * StaticConfigHandler.pixelsPerMeter;						trace("port: " + debugPort.x + ", " + debugPort.y);			debugPin.x = shipBody.GetWorldPoint(new b2Vec2(0, -1.65)).x * StaticConfigHandler.pixelsPerMeter;			debugPin.y = shipBody.GetWorldPoint(new b2Vec2(0, -1.65)).y * StaticConfigHandler.pixelsPerMeter;						trace("pin: " + debugPin.x, ", " + debugPin.y);						//debugPin.x = 320;			//debugPin.y = 110;					}*/	}}