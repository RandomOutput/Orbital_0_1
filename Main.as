package{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Dynamics.Joints.*;	import Box2D.Dynamics.Contacts.*;	import Box2D.Common.Math.*;	import StaticConfigHandler;	import StaticInputHandler;		public class Main extends MovieClip	{		private var world:b2World;		private var timestep:Number;		private var iterations:uint;		//var shipBody:b2Body;		var dock_body:b2Body;		var ship:CSM;		var debugPort:MovieClip;		var debugPin:MovieClip;		var ships:Vector.<Part>; 		public function Main()		{			super();						ships = new Vector.<Part>();						makeWorld();			makeWalls();			//makeDebugDraw();			if(stage) init();			else addEventListener(Event.ADDED_TO_STAGE, init);		}		private function makeWorld():void		{			//define gravity			var gravity:b2Vec2 = new b2Vec2(0.0, 0.0);			//Allow bodies to sleep			var doSleep:Boolean = true;			//Construct a world;			world = new b2World(gravity, doSleep);			world.SetWarmStarting(true);			timestep = 1.0 / 30.0;			iterations = 10;		}		private function makeWalls():void		{			var wall:b2PolygonShape = new b2PolygonShape();			var wallBd:b2BodyDef = new b2BodyDef();			var wallB:b2Body;			//Left			wallBd.position.Set( -95 / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wall.SetAsBox(100/StaticConfigHandler.pixelsPerMeter, 400/StaticConfigHandler.pixelsPerMeter/2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Right			wallBd.position.Set((640 + 95) / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Top			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, -95 / StaticConfigHandler.pixelsPerMeter);			wall.SetAsBox(680/StaticConfigHandler.pixelsPerMeter/2, 100/StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Bottom			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, (400 + 95) / StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);		}		private function makeDebugDraw():void		{			var debugDraw:b2DebugDraw = new b2DebugDraw();			var debugSprite:Sprite = new Sprite();			addChild(debugSprite);			debugDraw.SetSprite(debugSprite);			debugDraw.SetDrawScale(30.0);			debugDraw.SetFillAlpha(0.3);			debugDraw.SetLineThickness(1.0);			debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);			world.SetDebugDraw(debugDraw);		}		private function init(e:Event = null):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			stage.addEventListener(KeyboardEvent.KEY_DOWN, StaticInputHandler.onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, StaticInputHandler.onKeyUp);						StaticConfigHandler.LEFT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.RIGHT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.UP_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.DOWN_VEC.Multiply(StaticConfigHandler.FORCE_MULT);						createShip();			createDockingPort();			createDebugPoints();			addEventListener(Event.ENTER_FRAME, update);		}		private function createDebugPoints():void		{			debugPort = new DebugPoint();			debugPin = new DebugPoint();			stage.addChild(debugPort);			stage.addChild(debugPin);		}		private function createShip():void		{			var newPart = new Part(world, "playerShip");			ships.push(newPart);		}		private function createDockingPort():void		{			var newPart = new Part(world, "Quad Connector");			ships.push(newPart);		}		private function update(e:Event = null):void		{			for (var i:int=0; i<ships.length; i++)			{				var ship:Part = ships[i];				if(ship.justCreated) this.addChild(ship);				ship.checkDocking(ships, i);				ship.update();			}			world.Step(timestep, iterations, iterations);			world.ClearForces();			world.DrawDebugData();		}	}}