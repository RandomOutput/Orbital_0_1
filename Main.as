package{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Dynamics.Joints.*;	import Box2D.Dynamics.Contacts.*;	import Box2D.Common.Math.*;	import StaticConfigHandler;	import StaticInputHandler;		public class Main extends MovieClip	{		private var world:b2World;		private var timestep:Number;		private var iterations:uint;		//var shipBody:b2Body;		var dock_body:b2Body;		var ship:CSM;		var debugPort:MovieClip;		var debugPin:MovieClip;		var ships:Vector.<Part>; 		public function Main()		{			super();						ships = new Vector.<Part>();						makeWorld();			makeWalls();			makeDebugDraw();			if(stage) init();			else addEventListener(Event.ADDED_TO_STAGE, init);		}		private function makeWorld():void		{			//define gravity			var gravity:b2Vec2 = new b2Vec2(0.0, 0.0);			//Allow bodies to sleep			var doSleep:Boolean = true;			//Construct a world;			world = new b2World(gravity, doSleep);			world.SetWarmStarting(true);			timestep = 1.0 / 30.0;			iterations = 10;		}		private function makeWalls():void		{			var wall:b2PolygonShape = new b2PolygonShape();			var wallBd:b2BodyDef = new b2BodyDef();			var wallB:b2Body;			//Left			wallBd.position.Set( -95 / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wall.SetAsBox(100/StaticConfigHandler.pixelsPerMeter, 400/StaticConfigHandler.pixelsPerMeter/2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Right			wallBd.position.Set((640 + 95) / StaticConfigHandler.pixelsPerMeter, 400 / StaticConfigHandler.pixelsPerMeter / 2);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Top			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, -95 / StaticConfigHandler.pixelsPerMeter);			wall.SetAsBox(680/StaticConfigHandler.pixelsPerMeter/2, 100/StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);			// Bottom			wallBd.position.Set(640 / StaticConfigHandler.pixelsPerMeter / 2, (400 + 95) / StaticConfigHandler.pixelsPerMeter);			wallB = world.CreateBody(wallBd);			wallB.CreateFixture2(wall);		}		private function makeDebugDraw():void		{			var debugDraw:b2DebugDraw = new b2DebugDraw();			var debugSprite:Sprite = new Sprite();			addChild(debugSprite);			debugDraw.SetSprite(debugSprite);			debugDraw.SetDrawScale(30.0);			debugDraw.SetFillAlpha(0.3);			debugDraw.SetLineThickness(1.0);			debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);			world.SetDebugDraw(debugDraw);		}		private function init(e:Event = null):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			stage.addEventListener(KeyboardEvent.KEY_DOWN, StaticInputHandler.onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, StaticInputHandler.onKeyUp);						StaticConfigHandler.LEFT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.RIGHT_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.UP_VEC.Multiply(StaticConfigHandler.FORCE_MULT);			StaticConfigHandler.DOWN_VEC.Multiply(StaticConfigHandler.FORCE_MULT);						createShip();			createDockingPort();			createDebugPoints();			addEventListener(Event.ENTER_FRAME, update);			//ship = new CSM();			//stage.addChild(ship);			//ship.alpha = 0.5;		}		private function createDebugPoints():void		{			debugPort = new DebugPoint();			debugPin = new DebugPoint();			stage.addChild(debugPort);			stage.addChild(debugPin);		}		private function createShip():void		{			var newPart = new Part(world);			//var newShip = new Ship(world, newPart);			ships.push(newPart);			/*			var shipBd:b2BodyDef;			var fd:b2FixtureDef;			var boxDef:b2PolygonShape = new b2PolygonShape();			shipBd = new b2BodyDef();			shipBd.type = b2Body.b2_dynamicBody;			fd = new b2FixtureDef();			fd.shape = boxDef;			fd.density = 1;			fd.friction = 0.5;			fd.restitution = 0.1;			boxDef.SetAsBox(41 / 2 / StaticConfigHandler.pixelsPerMeter, 100 / 2 / StaticConfigHandler.pixelsPerMeter);			shipBd.position.Set(320 / StaticConfigHandler.pixelsPerMeter, 240 / StaticConfigHandler.pixelsPerMeter);			shipBody = world.CreateBody(shipBd);			shipBody.CreateFixture(fd);			*/		}		private function createDockingPort():void		{			var newPart = new Part(world, "Static Station");			//var newShip = new Ship(world, newPart);			ships.push(newPart);			/*			var bd_dock:b2BodyDef = new b2BodyDef();			bd_dock.type = b2Body.b2_staticBody;			bd_dock.position.Set(100 / StaticConfigHandler.pixelsPerMeter, 50 / StaticConfigHandler.pixelsPerMeter);						var boxDef:b2PolygonShape = new b2PolygonShape();			boxDef.SetAsBox(50/2/StaticConfigHandler.pixelsPerMeter, 50/2/StaticConfigHandler.pixelsPerMeter);			var fd_dock:b2FixtureDef = new b2FixtureDef();			fd_dock.shape = boxDef;			fd_dock.density = 1;			fd_dock.friction = 0.5;			fd_dock.restitution = 0.1;						dock_body = world.CreateBody(bd_dock);			dock_body.CreateFixture(fd_dock);				*/				}		private function update(e:Event = null):void		{			for (var i:int=0; i<ships.length; i++)			{				var ship:Part = ships[i];				if(ship.justCreated) this.addChild(ship);				ship.checkDocking(ships, i);				ship.update();			}			world.Step(timestep, iterations, iterations);			world.ClearForces();			world.DrawDebugData();		}		/*		private function checkDocking():void		{			//docking port b2Vec2			var dockingPort:b2Vec2 = dock_body.GetWorldPoint(new b2Vec2(.8,0));						//docking pin b2Vec2			var dockingPin:b2Vec2 = shipBody.GetWorldPoint(new b2Vec2(0,-1.65));			//distance			var dist:Number = Math.sqrt(Math.pow(dockingPort.x - dockingPin.x, 2) + Math.pow(dockingPort.y - dockingPin.y, 2));			dist = dist * StaticConfigHandler.pixelsPerMeter;						//relative angle			var relAngle:Number = Math.abs(dock_body.GetAngle() - shipBody.GetAngle());			relAngle = relAngle * ( 180 / Math.PI );			relAngle -= 90;						trace("dist: " + dist);			trace("relAngle: " + relAngle);			//if distance and angle good			if(dist < 3 && relAngle < 5 && relAngle > -5)			{				//create joint & lock				var revoluteJointDef:b2RevoluteJointDef = new  b2RevoluteJointDef();				revoluteJointDef.Initialize(dock_body, shipBody, dockingPin);				 				revoluteJointDef.maxMotorTorque = 1.0;				revoluteJointDef.enableMotor = true;				 				world.CreateJoint(revoluteJointDef);				dock_body.SetType(2);			}		}		*/	}}